# This workflow will:
# - build and push a docker image using  skaffold
# - always make a pull request in the deploy repo to update staging & auto merge it
# - on release tags (v...), also make a draft pull request to update prod

# It is designed to be called from the source repo.
# Assumes the deploy repo is named {source_code_repo}-deploy

name: Continous Deployment

on:
  workflow_call:

jobs:
  container:
    runs-on: ubuntu-latest
    concurrency:
      group: cd-container

    permissions:
      packages: write
      contents: read

    env:
      REGISTRY: ghcr.io

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Determine changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          base: ${{ github.ref }}
          filters: |
            k8s:
              - 'k8s/**'
            src:
              - '!k8s/**'

      - name: Install Nix
        uses: nixbuild/nix-quick-install-action@v26

      - name: Restore and cache Nix store
        uses: nix-community/cache-nix-action@v4
        with:
          key: nix-${{ runner.os }}-${{ hashFiles('devenv.*') }}
          restore-keys: |
            nix-${{ runner.os }}-
          purge: true
          purge-keys: |
            nix-${{ runner.os }}-

      - name: Install devenv.sh
        run: nix profile install tarball+https://install.devenv.sh/latest

      - name: Build the devenv shell and run any pre-commit hooks
        run: devenv ci

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cache/restore skaffold
        uses: actions/cache@v3
        with:
          path: ~/.skaffold/
          key: skaffold-${{ github.sha }}
          restore-keys: |
            skaffold-

      - name: Build and push container image
        id: skaffold
        shell: devenv shell bash -e {0}
        if: steps.changes.outputs.src == 'true'
        env:
          SKAFFOLD_DEFAULT_REPO: ${{ env.REGISTRY }}/${{ github.repository }}
        run: |
          skaffold build -p app --file-output build-artifacts.json
          echo "buildArtifacts=$(cat build-artifacts.json)" >> "$GITHUB_OUTPUT"

    outputs:
      skaffoldBuildArtifacts: ${{ steps.skaffold.outputs.buildArtifacts }} || '{}'

  update:
    runs-on: ubuntu-latest
    needs: container
    concurrency:
      group: cd-update

    steps:
      - name: Get a token as lco-deploy-bot
        uses: actions/create-github-app-token@v1
        id: lco-deploy-bot
        with:
          app-id: ${{ secrets.LCO_DEPLOY_BOT_APP_ID }}
          private-key: ${{ secrets.LCO_DEPLOY_BOT_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Checkout deploy repo
        uses: actions/checkout@v4
        with:
          token: ${{ steps.lco-deploy-bot.outputs.token }}
          repository: ${{ github.repository }}-deploy
          persist-credentials: false
          ref: 'main'

      - name: Install Nix
        uses: nixbuild/nix-quick-install-action@v26

      - name: Restore and cache Nix store
        uses: nix-community/cache-nix-action@v4
        with:
          key: nix-${{ runner.os }}-${{ hashFiles('devenv.*') }}
          restore-keys: |
            nix-${{ runner.os }}-
          purge: true
          purge-keys: |
            nix-${{ runner.os }}-

      - name: Install Cachix
        uses: cachix/cachix-action@v12
        with:
          skipPush: true
          name: devenv
          extraPullNames: lco-public

      - name: Install devenv.sh
        run: nix profile install tarball+https://install.devenv.sh/latest

      - name: Configure Git to use lco-deploy-bot token
        run: |
          git config --global url."https://x-access-token:${{ steps.lco-deploy-bot.outputs.token }}@github.com".insteadOf "https://github.com"

      - name: Write skaffoldBuildArtifacts to file
        run: |
          echo -n '${{ toJson(needs.container.outputs.skaffoldBuildArtifacts) }}' > "${{ github.workspace }}"/images.json

      - name: Determine commit/pr metadata
        id: common
        uses: actions/github-script@v7
        with:
          script: |
            const botName = "${{ vars.LCO_DEPLOY_BOT_APP_NAME }}[bot]";
            const botActorId = "${{ vars.LCO_DEPLOY_BOT_APP_ACTOR_ID }}";
            const botEmail = `${botActorId}+${botName}@users.noreply.github.com`;

            const commitMessage = context.payload.head_commit.message;
            const commitLines = commitMessage.split("\n");
            const commitSubject = commitLines.at(0);
            const commitBody = commitLines.slice(1).join("\n");

            const commitUrl = context.payload.head_commit.url;

            const coAuthoredBy = "Co-authored-by: ${{ github.actor }} <${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com>";

            let prCommitTitle = commitSubject;
            let prCommitBody = `Source-commit: ${commitUrl}\n\n${commitBody}`;
            let prBody = `${commitUrl}\n\n${commitBody}`;

            if (process.env.GITHUB_REF_TYPE === "tag") {
              const tag = process.env.GITHUB_REF_NAME;
              const release = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tag,
              });

              if (release.status === 200 ) {
                prCommitTitle = `release: ${release.data.title}`;
                const releaseId = `${context.repo.owner}/${context.repo.repo}/${tag}`;
                const releaseNotesTemplate = `{{ githubRelease "${releaseId}" | expandGithubLinks "${process.env.GITHUB_REPOSITORY}" }}`;

                prCommitBody = releaseNotesTemplate;
                prBody = releaseNotesTemplate;
              }
            }

            prCommitBody += `\n\n${coAuthoredBy}`;
            prBody += `\n\n@${context.actor}`;

            core.setOutput("botName", botName);
            core.setOutput("botEmail", botEmail);
            core.setOutput("prCommitTitle", prCommitTitle);
            core.setOutput("prCommitBody", prCommitBody);
            core.setOutput("prBody", prBody);

      - name: Create staging PR
        shell: devenv shell bash -e {0}
        run: |
          echo '${{ steps.common.outputs.result }}'
          octopilot \
            --fail-on-error --log-level debug \
            --github-auth-method app \
            --github-app-id '${{ secrets.LCO_DEPLOY_BOT_APP_ID }}' \
            --github-installation-id '${{ secrets.LCO_DEPLOY_BOT_APP_INSTALL_ID }}' \
            --github-privatekey '${{ secrets.LCO_DEPLOY_BOT_APP_PRIVATE_KEY }}' \
            \
            --repo '${{ github.repository }}-deploy' \
            \
            --update 'exec(cmd=cd-update-staging,args=`${{ github.workspace }}/images.json` `${{ github.sha }}`)' \
            \
            --git-author-name '${{ steps.common.outputs.botName }}' \
            --git-author-email '${{ steps.common.outputs.botEmail }}' \
            --git-committer-name '${{ steps.common.outputs.botName }}' \
            --git-committer-email '${{ steps.common.outputs.botEmail }}' \
            --git-commit-title 'staging: ${{ steps.common.outputs.prCommitTitle }}' \
            --git-commit-body  '${{ steps.common.outputs.prCommitBody }}' \
            --git-commit-footer '' \
            \
            --pr-base-branch main \
            --pr-labels octopilot,staging,sha=${{ github.sha }} \
            --pr-title 'staging: ${{ steps.common.outputs.prCommitTitle }}' \
            --pr-body '${{ steps.common.outputs.prBody }}'

      - run: npm install @octokit/request-error

      # This is a hack until octopilot supports Github's auto-merge feature.
      - name: Auto merge staging PR
        id: staging
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.lco-deploy-bot.outputs.token }}
          script: |
            const { RequestError } = require("@octokit/request-error");

            const sha = context.sha;
            const pullRequestQuery = `
              query {
                search(
                  type: ISSUE,
                  query: "repo:${context.repo.owner}/${context.repo.repo}-deploy type:pr state:open label:octopilot label:staging label:sha=${sha}",
                  first: 2
                ){
                  issueCount,
                  nodes {
                    ... on PullRequest {
                      id
                      number
                    }
                  }
                }
              }
            `;

            console.log(pullRequestQuery);

            let pullRequest;

            while (true) {

              const pullRequests = await github.graphql(pullRequestQuery);

              if (pullRequests.search.issueCount == 1) {
                console.log(pullRequests);
                pullRequest = pullRequests.search.nodes[0];
                break;
              }

              if (pullRequests.search.issueCount > 1) {
                throw new Error("unable to find matching PR");
              }

              await new Promise(r => setTimeout(r, 1000));
            }

            // remove label to avoid cluttering
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: `${context.repo.repo}-deploy`,
              issue_number: pullRequest.number,
              name: `sha=${sha}`,
            });

            const enableAutoMergeMutation = `
              mutation($id: ID!) {
                enablePullRequestAutoMerge(input: {pullRequestId: $id, }){
                  pullRequest {
                    number
                  }
                }
              }
            `;

            const autoMergeVars = {
              id: pullRequest.id
            };

            const autoMergeResponse = await github.graphql(enableAutoMergeMutation, autoMergeVars);
            console.log(autoMergeResponse);

            // wait for it to be merged
            while (true) {
              try {
                const merged = await github.rest.pulls.checkIfMerged({
                  owner: context.repo.owner,
                  repo: `${context.repo.repo}-deploy`,
                  pull_number: pullRequest.number,
                });
                console.log(merged);
                break;
              } catch (error) {
                if (error.status === 404) {
                  await new Promise(r => setTimeout(r, 1000));
                  continue;
                }
                throw error;
              }
            }

            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: `${context.repo.repo}-deploy`,
              pull_number: pullRequest.number,
            });

            core.setOutput("mergeCommit", pr.data.merge_commit_sha);
