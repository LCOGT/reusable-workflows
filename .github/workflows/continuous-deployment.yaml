# This workflow will:
# - build and push a docker image using  skaffold
# - always make a pull request in the deploy repo to update staging & auto merge it
# - on release tags (v...), also make a draft pull request to update prod

# It is designed to be called from the source repo.

name: Continuous Deployment

on:
  workflow_call:
    inputs:
      skaffoldBuildProfiles:
        type: string
        description: Comma seperated list of Skaffold profile(s) to use for building container(s).
        required: true
        default: "app"
        
      skaffoldBuildModules:
        type: string
        description: Comma seperated list of Skaffold modules(s) to use for building container(s). By default all modules are used.
        required: true
        default: ""

      submodules:
        type: string
        description: "`true` to checkout submodules or `recursive` to recursively checkout submodules."
        required: true
        default: "false"

      deployRepo:
        type: string
        description: >
          Name of the deploy repo. By default this is just the name of the source repo with `-deploy` appended to it."
        required: true
        default: ""

jobs:
  container:
    runs-on: ubuntu-latest
    concurrency:
      group: cd-container

    permissions:
      packages: write
      contents: read

    env:
      REGISTRY: ghcr.io

    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Expose GitHub Runtime
        uses: crazy-max/ghaction-github-runtime@v3

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          submodules: ${{ inputs.submodules }}

      - name: Install Nix
        uses: cachix/install-nix-action@v24
        with:
          extra_nix_config: |
            accept-flake-config = true

      - uses: DeterminateSystems/magic-nix-cache-action@main

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cache/restore skaffold
        uses: actions/cache@v3
        with:
          path: ~/.skaffold/
          key: skaffold-${{ github.sha }}
          restore-keys: |
            skaffold-

      - name: Build and push container image
        id: skaffold
        env:
          SKAFFOLD_BUILDX_ARGS: "--cache-to type=gha,mode=max,ignore-error=true --cache-from type=gha"
        run: nix develop --impure --command skaffold build -m '${{ inputs.skaffoldBuildModules }}' -p '${{ inputs.skaffoldBuildProfiles }}' --file-output built-images.json --default-repo '${{ env.REGISTRY }}/${{ github.repository }}'

      - name: Upload Skaffold build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: skaffold-build
          path: built-images.json

  update:
    env:
      deployOrgRepo: ${{ (inputs.deployRepo && format('{0}/{1}', github.repository_owner, inputs.deployRepo)) || format('{0}-deploy', github.repository) }}
    runs-on: ubuntu-latest
    needs: container
    concurrency:
      group: cd-update

    steps:
      - name: Get a token as lco-deploy-bot
        uses: actions/create-github-app-token@v1
        id: lco-deploy-bot
        with:
          app-id: ${{ secrets.LCO_DEPLOY_BOT_APP_ID }}
          private-key: ${{ secrets.LCO_DEPLOY_BOT_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Install Nix
        uses: cachix/install-nix-action@v24
        with:
          extra_nix_config: |
            accept-flake-config = true

      - uses: DeterminateSystems/magic-nix-cache-action@main

      - name: Configure Git to use lco-deploy-bot token
        run: |
          git config --global url."https://x-access-token:${{ steps.lco-deploy-bot.outputs.token }}@github.com".insteadOf "https://github.com"

      - name: Download Skaffold build artifacts
        uses: actions/download-artifact@v4
        with:
          name: skaffold-build

      - name: Gather commit/PR metadata
        id: common
        uses: actions/github-script@v7
        with:
          script: |
            const botName = "${{ vars.LCO_DEPLOY_BOT_APP_NAME }}[bot]";
            const botActorId = "${{ vars.LCO_DEPLOY_BOT_APP_ACTOR_ID }}";
            const botEmail = `${botActorId}+${botName}@users.noreply.github.com`;

            const coAuthoredBy = "Co-authored-by: ${{ github.actor }} <${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com>";

            let prCommitTitle;

            const prCommitBodyElms = [];
            const prBodyElms = [];

            if (context.eventName === "release") {
              const release = context.payload.release;

              prCommitTitle = `release: ${release.name}`;

              const ownerRepo = `${context.repo.owner}/${context.repo.repo}`;
              const releaseId = `${ownerRepo}/${release.tag_name}`;
              const releaseNotesTemplate = `{{ githubRelease "${releaseId}" | expandGithubLinks "${ownerRepo}" }}`;

              prCommitBodyElms.push(releaseNotesTemplate);
              prBodyElms.push(releaseNotesTemplate);
            } else {
              const commitMessage = context.payload.head_commit.message;
              const commitLines = commitMessage.split("\n");
              const commitSubject = commitLines.at(0);
              const commitBody = commitLines.slice(1).join("\n");

              const commitUrl = context.payload.head_commit.url;

              prCommitTitle = commitSubject;

              prCommitBodyElms.push(`Source-commit: ${commitUrl}`, commitBody);
              prBodyElms.push(`Source-commit: ${commitUrl}`, commitBody);
            }

            prCommitBodyElms.push(coAuthoredBy);

            prCommitBody = prCommitBodyElms.filter(x => x).join("\n\n");
            prBody = prBodyElms.filter(x => x).join("\n<br>\n");

            core.setOutput("botName", botName);
            core.setOutput("botEmail", botEmail);
            core.setOutput("prCommitTitle", prCommitTitle);
            core.setOutput("prCommitBody", prCommitBody);
            core.setOutput("prBody", prBody);

      - name: Create & merge staging PR
        run: |
          nix run github:LCOGT/devenv-k8s#octopilot -- \
            --fail-on-error --log-level debug \
            --github-auth-method app \
            --github-app-id '${{ secrets.LCO_DEPLOY_BOT_APP_ID }}' \
            --github-installation-id '${{ secrets.LCO_DEPLOY_BOT_APP_INSTALL_ID }}' \
            --github-privatekey '${{ secrets.LCO_DEPLOY_BOT_APP_PRIVATE_KEY }}' \
            \
            --repo '${{ env.deployOrgRepo }}' \
            \
            --update 'exec(cmd=nix,args=develop --impure --command cd-update-staging `${{ github.workspace }}/built-images.json` `${{ github.sha }}`)' \
            \
            --git-branch-prefix 'octopilot-staging-' \
            --git-author-name '${{ steps.common.outputs.botName }}' \
            --git-author-email '${{ steps.common.outputs.botEmail }}' \
            --git-committer-name '${{ steps.common.outputs.botName }}' \
            --git-committer-email '${{ steps.common.outputs.botEmail }}' \
            --git-commit-title 'staging: ${{ steps.common.outputs.prCommitTitle }}' \
            --git-commit-body  '${{ steps.common.outputs.prCommitBody }}' \
            --git-commit-footer '' \
            \
            --pr-base-branch main \
            --pr-labels octopilot,staging \
            --pr-assignees '${{ github.actor }}' \
            --pr-title 'staging: ${{ steps.common.outputs.prCommitTitle }}' \
            --pr-body '${{ steps.common.outputs.prBody }}' \
            --pr-merge \
            --pr-merge-auto \
            --pr-merge-auto-wait \
            --output-results staging-pr.json

      - name: Annotate w/ staging PR
        uses: actions/github-script@v7
        with:
          script: |
            const { readFile } = require("fs/promises");
            const data = JSON.parse(await readFile("staging-pr.json", "utf8"));

            const pr = data.repos[0].pr;
            const description = `Staging deploy PR #${pr.number}`;

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: "success",
              context: "cd/staging/pr",
              description: description,
              target_url: pr.url
            });

            core.summary.addLink(description, pr.url);
            core.summary.write();

      - name: Get staging PR metadata
        if: github.event_name == 'release' && startsWith(github.event.release.tag_name, 'v')
        id: staging-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.lco-deploy-bot.outputs.token }}
          script: |
            const { readFile } = require("fs/promises");
            const data = JSON.parse(await readFile("staging-pr.json", "utf8"));

            cons repo = data.repos[0];

            const pr_number = repo.pr.number;

            const pr = await github.rest.pulls.get({
              owner: repo.owner,
              repo: repo.repo,
              pull_number: pr_number,
            });

            const sha = pr.data.merge_commit_sha;

            core.setOutput("sha", sha);

      - name: Create prod PR
        if: github.event_name == 'release' && startsWith(github.event.release.tag_name, 'v')
        run: |
          nix run github:LCOGT/devenv-k8s#octopilot -- \
            --fail-on-error --log-level debug \
            --github-auth-method app \
            --github-app-id '${{ secrets.LCO_DEPLOY_BOT_APP_ID }}' \
            --github-installation-id '${{ secrets.LCO_DEPLOY_BOT_APP_INSTALL_ID }}' \
            --github-privatekey '${{ secrets.LCO_DEPLOY_BOT_APP_PRIVATE_KEY }}' \
            \
            --repo '${{ env.deployOrgRepo }}' \
            \
            --update 'exec(cmd=nix,args=develop --impure --command cd-update-prod `${{ steps.staging-pr.outputs.sha }}`)' \
            \
            --git-branch-prefix 'octopilot-prod-' \
            --git-author-name '${{ steps.common.outputs.botName }}' \
            --git-author-email '${{ steps.common.outputs.botEmail }}' \
            --git-committer-name '${{ steps.common.outputs.botName }}' \
            --git-committer-email '${{ steps.common.outputs.botEmail }}' \
            --git-commit-title 'prod: ${{ steps.common.outputs.prCommitTitle }}' \
            --git-commit-body  '${{ steps.common.outputs.prCommitBody }}' \
            --git-commit-footer '' \
            \
            --pr-base-branch main \
            --pr-labels octopilot,prod \
            --pr-assignees '${{ github.actor }}' \
            --pr-title 'prod: ${{ steps.common.outputs.prCommitTitle }}' \
            --pr-body '${{ steps.common.outputs.prBody }}' \
            --output-results prod-pr.json

      - name: Annotate w/ prod PR
        uses: actions/github-script@v7
        if: github.event_name == 'release' && startsWith(github.event.release.tag_name, 'v')
        with:
          script: |
            const { readFile } = require("fs/promises");
            const data = JSON.parse(await readFile("prod-pr.json", "utf8"));

            const pr = data.repos[0].pr;
            const description = `Prod deploy PR #${pr.number}`;

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: "success",
              context: "cd/prod/pr",
              description: description,
              target_url: pr.url
            });

            core.summary.addLink(description, pr.url);
            core.summary.write();
